"""
CMake Helper - Utilities for CMake project configuration
"""

import subprocess
import shutil
from pathlib import Path
import json


class CMakeHelper:
    """Utilities for working with CMake projects"""

    @staticmethod
    def has_cmake():
        """Check if cmake is available in PATH"""
        return shutil.which("cmake") is not None

    @staticmethod
    def detect_cmake_project(project_path):
        """
        Detect if a directory contains a CMake project

        Args:
            project_path: Path to project directory

        Returns:
            bool: True if CMakeLists.txt found
        """
        project_path = Path(project_path)
        return (project_path / "CMakeLists.txt").exists()

    @staticmethod
    def configure_project(project_path, build_dir="build", extra_args=None):
        """
        Configure CMake project with compile_commands.json export

        Args:
            project_path: Path to project directory
            build_dir: Build directory name (default: "build")
            extra_args: Additional CMake arguments (list)

        Returns:
            tuple: (success, message, compile_commands_path)
        """
        project_path = Path(project_path)
        build_path = project_path / build_dir

        # Check if cmake is available
        if not CMakeHelper.has_cmake():
            return False, "cmake not found in PATH", None

        # Check for CMakeLists.txt
        if not CMakeHelper.detect_cmake_project(project_path):
            return False, f"CMakeLists.txt not found in {project_path}", None

        # Create build directory
        build_path.mkdir(parents=True, exist_ok=True)

        # Build cmake command
        cmake_args = [
            "cmake",
            "-B", str(build_path),
            "-S", str(project_path),
            "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"
        ]

        # Add extra args if provided
        if extra_args:
            cmake_args.extend(extra_args)

        # Run cmake configuration
        try:
            result = subprocess.run(
                cmake_args,
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )

            if result.returncode != 0:
                error_msg = result.stderr or result.stdout
                return False, f"CMake configuration failed:\n{error_msg}", None

            # Check if compile_commands.json was generated
            compile_commands_path = build_path / "compile_commands.json"
            if not compile_commands_path.exists():
                return False, "compile_commands.json not generated by CMake", None

            # Validate it's valid JSON
            try:
                with open(compile_commands_path, "r") as f:
                    compile_data = json.load(f)
                    if not isinstance(compile_data, list):
                        return False, "compile_commands.json has invalid format", None
            except json.JSONDecodeError as e:
                return False, f"compile_commands.json is not valid JSON: {e}", None

            return True, "CMake configuration successful", compile_commands_path

        except subprocess.TimeoutExpired:
            return False, "CMake configuration timed out (>5 minutes)", None
        except Exception as e:
            return False, f"CMake configuration error: {e}", None

    @staticmethod
    def get_file_count(compile_commands_path):
        """
        Get file count from compile_commands.json

        Args:
            compile_commands_path: Path to compile_commands.json

        Returns:
            int: Number of compilation units
        """
        try:
            with open(compile_commands_path, "r") as f:
                compile_data = json.load(f)
                return len(compile_data)
        except Exception:
            return 0

    @staticmethod
    def validate_compile_commands(compile_commands_path):
        """
        Validate compile_commands.json file

        Args:
            compile_commands_path: Path to compile_commands.json

        Returns:
            tuple: (is_valid, issues)
        """
        issues = []
        compile_commands_path = Path(compile_commands_path)

        # Check file exists
        if not compile_commands_path.exists():
            return False, ["File does not exist"]

        # Check it's valid JSON
        try:
            with open(compile_commands_path, "r") as f:
                compile_data = json.load(f)
        except json.JSONDecodeError as e:
            return False, [f"Not valid JSON: {e}"]

        # Check it's a list
        if not isinstance(compile_data, list):
            issues.append("Root element must be a JSON array")

        # Check entries have required fields
        if isinstance(compile_data, list) and compile_data:
            first_entry = compile_data[0]
            required_fields = ["directory", "command", "file"]
            for field in required_fields:
                if field not in first_entry:
                    issues.append(f"Entry missing required field: {field}")

        return len(issues) == 0, issues
